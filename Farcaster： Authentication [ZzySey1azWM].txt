We've talked about how users can register farcaster IDs. In this case, Alice, who controls the address 0x1234, has registered the farcaster ID 3489. She now includes this ID in her messages to Bob. Now, we also need a way for this message to be authenticated. That is, when Bob gets the message, he needs to know that it came from Alice, even if it was relayed to him through another server. One simple way we can do this is by taking advantage of the fact that Ethereum addresses are effectively public and private key pairs that can be used to produce cryptographic signatures. We can have Alice sign this message with a packet. She simply takes the message and produces a signature using a private key that she has. We know that Alice must have a private key that corresponds to the address 0x1234, and she can simply use that private key to produce a signature, which she includes in the message. When Bob receives this message, all Bob has to do is take the author ID or the FID, look it up on the blockchain, find the corresponding public key or address in this case, and then check if the signature was produced by that address. Since only the person who controls the private key can produce that signature, Bob knows that this message must have come from the same person that registered this ID on the blockchain. This is a fairly straightforward authentication system. It's very simple. It uses cryptographic primitives that we're familiar with, and it's tamper-proof. This message can bounce through any number of untrusted servers and nobody can actually modify the message without also invalidating the signature. There is a slight problem with this approach though. Now, let's imagine that Alice actually has applications that she uses to browse the Forecaster Network. Maybe she has a phone that she uses from time to time. Now, one problem with this approach is that Alice needs to take this private key and actually load it on this device while using the application so that the app can actually produce the signature over here. This creates a bit of a problem because in many cases, the app that you're using might be a third-party application. It might not necessarily be something that you want to trust with your identity, because if the app is untrustworthy, it could actually steal your public and private key and actually steal your identity and then pretend to be Alice from now on. You can also imagine that Alice may be using multiple applications at once. So she wants a way to allow the application to publish messages on her behalf, which is fine because messages can be deleted even if the app goes rogue. But she doesn't necessarily want the applications to have full control over her identity. One way we approach this is we don't let the apps actually take what we call the custody key or the key that controls your identity. We actually have each application generate a separate key pair that we call a signer. This signer looks like this and it's generated on the device itself. What we actually have Alice do rather than produce the signature is we have Alice create another message called a signer message which includes this following content. So first it has the custody address or Alice's address 1234. Then it has a signer address. Let's say that this is 0x5678. Finally, it contains a signature from the custody address. Now let's see how these connect up here. The custody address is simply this address. It's what Alice originally has the key for. The signer address or this one over here is the new key pair generated by the phone. The signature is produced by the custody address or this address. Alice is effectively setting up a chain of trust from her custody address, which creates the signature, to the new signer address on this phone, telling the world that she's okay with this signer now creating messages on her behalf. Now we can have this signer actually produce this signature down on this message over here, and we've created a chain of trust linking this ID to this key pair, which Alice controls, to this message, which authorizes a key pair on her phone, to this message, which then gets delivered to Bob. Now Bob can simply, as long as Bob has access to both of these messages, Bob can simply walk through this chain of trust and establish that this message actually came from Alice. This is a very simple cryptographic system that allows a user to establish a chain of trust going from a forecaster ID, which is in a contract on the blockchain, all the way down to messages that are getting delivered to users. Now there's a couple of things to touch on here. One is, there's two components to our system. The area above the line over here exists on the Ethereum blockchain and establishes the forecaster IDs and keys, while the area down here works outside of the blockchain and is largely a sequence of messages that chain from this ID registry all the way down to actions taken by the user. We haven't yet talked about how these messages work or where exactly they're stored, and that's going to be the subject of our future videos, where we explore how this area under the line or the layer 2 works.