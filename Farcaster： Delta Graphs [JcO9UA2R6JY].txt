We've previously talked about how we use messages to represent actions taken by users on a social network and that hubs just store and share these messages between each other. Today I want to get a little bit more specific about how exactly messages are stored and shared between hubs. We're going to introduce a new concept called the Delta Graph. So we'll define a delta as something that a user can do on a social network. It could be as something as simple as Alice says, Hello world! Which is a type of delta known as a cast, where you're broadcasting something into the world. It could also be something along the lines of Bob likes Hello World, which is a reaction or a response to something that someone else has already done. It could also be something like a share or as we call them recasts, where Bob shares the message Hello World to people that are subscribed to him. There's also other types of more complex interactions where Bob might actually reply, Welcome to Hello World! So he's actually saying something but is connecting it to another piece of data on the network. And so you can sort of see how a simple set of instructions, you know, reactions, replies, messages, etc. can be used to compose most common social actions that people do. But one of the interesting things that happens is when people create deltas that conflict with each other. So for example, let's say that Bob at a later date decides to unlike this message. So now we have sort of a Bob likes Hello World. If a hub was simply a collection of deltas like this, we now have a problem. When a developer sees this data, the developer sees two conflicting messages. It says here that Bob likes Hello World and Bob unlikes Hello World. And obviously both of them can't be true at the same time. And so we need a way to actually resolve this conflict and figure out what the current state of the network is. And it's important that hubs actually handle this so that developers get a consistent view of the social network. And so, you know, one developer doesn't decide that the like is the current state and the other developer doesn't decide that the unlike is the current state. Everyone needs to come to consensus on what the current state is when such conflicts exist. And so the other rule that we say is that the set of deltas must be combined using a set of rules to produce a valid social graph. Now, a graph is a very simple data structure that have vertices which represent content on the network. So in this case, something like Alice is actually a vertex and so is Bob. But vertices can also be used to represent content. So when Alice writes something, she's actually creating a new vertex for the world, but is also creating an edge or a relationship to that message, claiming that she's the parent of that message. So we can see that this delta over here produces this hello world and this line that connects this to it. And similarly, when Bob likes hello world and when Bob reacts to hello world, a recast hello world, he produces two additional messages of that sort as well, where this is a like relationship and the other one is a recast. Now, you can also visualize the reply in this sort of way, right, where you can go ahead and say that the reply welcome here is actually has the parent relationship to Bob and then also has a reply relationship to hello world. So this is sort of a more complex action that has introduced multiple edges and a single vertex. Now, it's clear that unlike, like and this sort of node over here all collide, right, because one of the rules of our social graph says that, hey, any two, a user and a piece of content may only have one relationship of a particular type. And so that that relationship can be either that the like is true or that the like is false, but it can't simultaneously be both unlike and like. And so hubs actually do a transformation. They actually do this sort of combine or merge function that takes a set of deltas, analyzes them and produces a valid social graph. And when it detects a conflict like this, it actually has a set of rules that can take these two messages and determine a single winner. So it might actually say that, hey, you know, the like is the older message. Let's get rid of it. And we actually know that unlike is the current state of the network. And it can do this in a way without needing consensus, without having to talk to any other hubs. All of the data needed to make this decision and reach consensus exists within the hub itself. And so this has a very, very nice property, right? If you go back and imagine that there's two different hubs that both have these messages, but each has a different sort of copy of the messages or each has a different set of messages, let's say. So this one doesn't have this one and this one doesn't have these two messages. A simple way that hubs can come into consensus is if they just swap their sets of messages and they both apply the same merge function. It's guaranteed to now produce the exact same social graph. So two hubs that have each gotten messages from different users just share all of these deltas together and then apply the merge function on the delta and the merge function guarantees that they always produce the same social graph. And this allows each hub to have the same representation that developers can call and pull and so on. Now, the merge function is sort of a lot of special magic, and we'll dive into that in a follow up video where we talk about how exactly this works and what are the different deltas and how they all interact with each other.