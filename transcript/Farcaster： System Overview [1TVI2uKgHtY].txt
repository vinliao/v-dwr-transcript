In this video, we'll introduce the idea of the layer cake, or the three layers that make up the forecaster network. So we've already talked about some of the primitives. Alice has a key pair that can be used to register an identity on the Ethereum blockchain using an ID contract. Alice can also use the same key pair to produce cryptographically signed messages. We haven't yet talked about where these messages get stored. A simple model for storage might have Alice just putting them on a server, almost like an RSS server of sorts, and Bob could do the same with his messages. You could index all of these different servers to get a copy of all data on the network. Now, a problem with this approach, like let's say you tried to build a search application that wanted to index the whole network and make it searchable. You would have to find every one of these servers, you'd have to deal with availability issues when these servers are offline, and run into all kinds of problems when indexing millions of users at scale. So Forecaster actually takes a different approach to availability, and takes advantage of the property that each of these is a signed tamper-proof message. So what happens on Forecaster is when Alice's server talks to Bob's server, it actually downloads a copy of Bob's messages, which it stores for future reference. And Bob's server does the same as well. It maintains a full copy of all of Alice's messages. That way, when Charlie enters the network with a blank hub, and wants to actually catch up with the network, it simply talks to Bob's server, and it can fetch an entire copy of both Alice's and Bob's messages. And we know that this is trustworthy, because Bob's server can't tamper without any of these messages, without affecting their signature. So this property, by turning each node in the network, or each hub, as we call them, into a peer-to-peer node that has a full copy of the network, we make data availability much simpler and much easier for anyone who joins the network in the future. Now, you also need applications to consume this data. Hubs aren't sufficient to just view social data on the network. And so you can imagine a simple application might just use something on your mobile phone to download messages from a hub and display them in chronological order. Hubs are fairly simple, right? They can just give you a list of messages and maybe order them by time, but they don't do much more than that. So this would be a fairly simple application that could just show you a chronological feed. Now, people do want more sophisticated applications, and you could build those in the system by introducing a proxy back in server. So in this case, you would actually have a server that talks to a hub and that downloads all of these messages from a hub. So it periodically syncs with the hub, pulls down all of these messages, organizes, categorizes them, does whatever fancy machine learning it wants to produce a feed, and then offers APIs that actually connect to mobile clients and generate a feed. And now, this sort of doesn't have to have map one-to-one to a user. A single application like this could actually serve thousands or even millions of users at a time by indexing all of this data. Now, I want to talk a little bit about the key model. So in this case, Alice would take her private key or her custody key and generate a delegate key pair, which would go into this mobile device and use this. And because Alice has control of this device, she has direct control of the key pair, and it's pretty straightforward. Now, in this model, the trust is delegated because Bob actually has to give a message to the server, which is what maintains a connection to the hub. And so Bob issues a delegate key pair to the server, which can now create messages on his behalf. So this is sort of a partially trusted model where Bob gives the server authority to create messages, but can use his custody key to revoke this at any time and move over to a different server or even use multiple servers at once. So these are sort of the ways in which you can build applications, fully decentralized applications that just run on clients that do very simple things, or much more powerful hybrid models where you have sort of this backend service doing some of the data processing and organizing data for you, and then mobile clients that actually download that data and display them to you in a useful and interesting manner. Now, this kind of sets up the idea of the three layers of the Forecaster Layer Kit, right? You have up here your first layer, which you can think of as your identity layer. So we'll call this identity. And this is built on the Ethereum blockchain. Down here, you have what we think of as a data layer, which is simply for the storage and replication of the data. And down here, you have the application layer, which is where you can build useful and interesting social applications by consuming data from this data layer. And they kind of all feed into each other, right? The identity layer establishes who can do things on the network and how they can authorize messages. The data layer stores messages authorized by those people and makes them available. And then finally, the application layer consumes those messages and generates useful feeds and also produces new messages when users create them with their clients and kind of pushes them back up into the data layer. Now, this is kind of an overview of the three parts of the Forecaster Network. There are a few important things we haven't touched on, which we'll cover in future videos, namely, how do we ensure that all of these messages can be stored on these servers and that we don't run out of space? How do we handle conflicts when users create messages that collide with each other? And finally, how do we actually ensure availability, that these messages are always available and that the sync is performing even as they're being sent?