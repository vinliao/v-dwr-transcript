All right, let's see if we can simplify our system further. So we have these two key chains on each side, which is used for encrypting messages to send and decrypting messages that are received. And we don't want to go through the hassle of maintaining separate public and private keys to derive and synchronize each of these things, because that's super messy. So to solve this, we take the same diagram we had before, just clean, it's just cleaned up a little bit and spaced out so we can draw some more stuff. And we introduced the notion of a root key pair. So our root key chain. So there's a new key chain called the root, which we'll mark in blue. And we actually use the private key and public key over here to derive this one, or this root key, instead of the one for the sending chain. So Alice produces this new key pair part. And then we have it produce another root key using the same notion of a key derivation function as we had before. And we also have this produce the output, which becomes the input for the sending key chain over here. So you can kind of see that this itself is its own key derivation function. And that links back to our sending key chain over here. And so the nice thing about this is you can just think of this as sort of like nested key chains. And Bob can use the same thing over on his side to derive the key chain. So we'll move this over here, we'll delete this one, we'll have this point back to this key chain, so that we know that this is deriving this key. And again, Bob derives this root key by combining Alice's public key and Bob's own private key, which then produces the key chain. Now remember, we need some private input over here in order to ensure that there's break in recovery. And so we have Alice and Bob generate a new key pair. And again, we take Alice's private key, feed it in here, we take Bob's public key, feed it in here, and then Bob performs the same operation on his side, except it's sort of connecting the other two keys. And so we've created a nested key chain where we've used the second pair of public keys as the input to produce this stuff. Now if Alice wants to send out another message, she can just run this key derivation function for her sending key chain just one more time over. So we basically take this, we kind of link this back up here, and then we can see that Alice can just call this function again, produce another key, and send it over here. And she can just do this as many times as she wants. Now we'll remove this and go back to the one message state just to keep it a little cleaner. Now let's say that Bob wants to send a message over. What we actually have Bob do is we want Bob to move the key derivation function one step forward so that we're not using the same keys all over again, and that there's some level of break in recovery. So we have Bob generate a new public and private key, we'll then mark this over here. And what we'll do is we'll tell Bob to derive a new root key, and also to derive a new initializer for his sending chain, which will become Alice's receiving chain. So we'll put this function over here, and then we will have a new root key produced down here. And then the inputs to this function are going to be Bob's new private key, which he just generated, and Alice's old public key, which she generated over here, which is no. So this produces a new key chain, it's used to encrypt the messages, and when Bob sends over the messages, he also just includes his public key, since that just makes it convenient for Alice, and it kind of goes over here and Alice is aware of it. Now when Alice wants to move this one step further and decrypt Bob's messages, she does the same function over on this side. She uses her last root key, which is the same as Bob's key, to pass it through a KDF function, and then to obtain another key, and again she has Bob's public key and her private key, which can again be combined, sort of the inverse of this operation, to produce the same secret, which will produce the same output, which will set up Bob's sending key. So you can kind of see that there's this nice property that emerges here, where within a set of messages, let's say between these two messages, we're using the same key derivation function, so if you break into K2, you can read K3 and so on. But every time the other person sends a message across, we're using a new public and private key pair to start a new Diffie-Hellman that changes the root key, and that's something you can't break into. You can only read the messages within this chain, and as soon as there's a ping-pong, the keys get rotated, the secret's changed, and now you can no longer derive the new key, because you as the attacker are not aware of the new public or private key that Alice or Bob introduced into this equation. So this is basically what's known as the double ratchet algorithm which Signal implements. It uses these different ratchets, a sending ratchet, a receiving ratchet, and the root ratchet, and uses Diffie-Hellman to keep generating new secrets to feed into the ratchets, making sure that every time messages go back and forth, the key material is changed and the secrets are rotated, ensuring that there's both forward secrecy and break-in recovery at all steps of this. Now in a future video, we'll explore some more aspects of this and dig into the double ratchet.