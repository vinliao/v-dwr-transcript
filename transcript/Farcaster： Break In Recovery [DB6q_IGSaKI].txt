Today's topic is break-in recovery, or specifically, how we can stop an attacker who learns K1 from being able to determine what K2, K3, and K4 are. The problem is that this KDF, or key derivation function between each of these steps, is deterministic and has the same input. So because we're always providing the same input, you can always keep determining this indefinitely, once you figure out one of these values. Fortunately, the KDF also accepts a second input, which can be used to change this value, deterministically. So if I send in a value X, this becomes a different K1. If I send in a value Y, this becomes a different K1. If we can get Alice and Bob to get another shared secret that changes at every step, we can have them put this into this value. And as long as we keep this value here secret from the attacker, we can move the chain forward, and an attacker who compromises K1 will only be able to determine M1, or one of the message keys, and will not be able to determine successive keys. They would have to break that secret value every time, which makes us much more resilient. Now luckily, we have a pretty good way for Alice and Bob to determine shared secrets. We already did this right up here. We used the private and public keys to determine the initial secret value K, which was used to seed this. So we can just kind of repeat this process for every step. So what we do is we have Alice set up a new key pair, and we also ask Bob to do the same over here. So Bob sets up another public and private key pair, and assume that Alice and Bob exchange their public keys. And they're both aware of this. Now to derive this first K1, Alice takes Bob's public key A as an input, and Alice takes her private key as an input. And she first does this process, the Diffie-Hellman, to produce a shared secret, and then feeds that as the input value into this algorithm. Now since Bob knows Alice's public key, and Bob also has his private key, he can perform the exact same step on the other side, getting the exact same shared secret. And so Alice and Bob can feed this shared secret in, and so a person who gets one value is not going to be able to know the next value, because they would also need to break this private key, which is securely generated on Alice and Bob's side. So that adds a layer of protection. And you can have Alice and Bob regenerate these keys for every step, and you can have them share the public key along with the message. So the idea is that you don't need a separate communication channel. You can just send the new public key along with your next message, and then Bob can use it and send a public key back. And you kind of go back and forth. And every time you have this new value going in, creating new secure message keys. Now there's a problem with this approach, which is it assumes that messages ping pong nicely. Alice sends a message, Bob sends a message back, et cetera, et cetera. But what happens if Bob sends two messages and Alice also simultaneously sends two messages? This creates a situation where these messages end up using the same key pair, and there becomes a... There enters some confusion around which message was encrypted with which key pair, because they don't always progress linearly like this. So to solve this, we introduce the notion of separate sending and receiving key pairs. We actually say that Alice has a key pair, or sorry, KDF, or key chain to encrypt her messages, and Bob has a key chain to encrypt his messages, and they're both aware of each other's chains. So we introduce a new chain over here, and we'll color code this differently so that we can tell these two apart. And what we do is we'll go ahead and make some modifications to this diagram over here to make this a little cleaner. We'll say that this only has one key generated so far, and that this has one key generated over here so far. So cool. So what Alice has done over here is Alice has generated the first key using her sending chain and sent it over to Bob. Now Bob's also aware of Alice's sending chain, which works out pretty well, so Bob is also able to derive the second key pair. Now when Bob wants to send out his message, Bob doesn't actually use the same key pair as we did before. Bob actually uses this other chain, which is over here, which is Bob's receiving chain... Or Bob's sending chain and Alice's receiving chain in order to generate the new key pair. And the nice property about this is if Bob were to send out another message, he could just go ahead and derive a new key from this, and this would work nicely, and you would get a deterministic key three. And if Alice were to do the same, you would sort of be able to get a new key over here that derived from this chain, and this would move forward. So Alice and Bob can now send a bunch of messages back and forth. Alice can send three or four messages, and they would all increment on this chain. Bob can send messages, and they would increment on this chain. And you wouldn't have this situation where messages on both sides got encrypted by the same key. Now the one thing about this is this sort of becomes tedious, right? You have to maintain separate public and private keys for this chain. You have to initialize this secret using a separate public key pair. So that kind of gets duplicate copies of everything, which is just a little painful to maintain. So in the next video, we'll discuss some systems to simplify this and make this a little easier.