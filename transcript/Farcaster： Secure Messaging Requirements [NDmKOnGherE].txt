Okay, so today we're going to talk about what makes a secure messaging protocol actually secure. So imagine that Alice is sending a message over to Bob through this protocol. We want to make sure that the protocol exhibits a few properties. The first of which is what we call anti-forgery. So what anti-forgery means is that Bob is able to verify on receipt of a message that Alice and only Alice was the author of that message and nobody else could have produced that message. So this is for obvious reasons an important foundation for any kind of messaging protocol. The second property that we care about is end-to-end encryption or E2E encryption. And most of you are probably familiar with this notion as well, but it's the idea that messages are encrypted and decrypted on the clients and at no point in flight in between those clients are they ever decrypted. And so the idea is that Alice's phone or desktop or laptop encrypts the message using a secret known only to Bob, sends this message over often using a server where it's encrypted and the message lands on Bob's device and then is often decrypted on his client. So end-to-end encryption ensures that as long as nobody knows the secret that Alice and Bob share, nobody's able to read the messages that are in flight between Alice and Bob. Now we'll get to some of the more interesting properties. There's another property that we care about called forward secrecy. And what forward secrecy means is that if the secret between Alice and Bob is compromised, a user can't use it to read all future messages produced by Alice and Bob. So if Alice and Bob just have a single shared secret and they use that to encrypt all of their messages, and if let's say Bob is clumsy and leaked that secret, then an attacker who has that secret can now read all the messages that Alice and Bob ever produce in the future, which is obviously not ideal. And we sort of assume that clients make mistakes or people make mistakes over time and keys might leak. And we want to ensure that we're not using a single secret to encrypt all the messages and that we have some durable system to ensure that if a secret is compromised, only a small portion of messages or ideally a single message is actually readable and the rest of the messages continue to remain secure. Now there's an extension to this idea that we call break-in recovery. And break-in recovery is the notion that if a break-in or a key compromise were to happen, then the system can actually heal itself so that they can continue communicating in a secure manner. So if Bob accidentally leaked one of his keys and it got compromised, we want to ensure that the system automatically self-heals or recovers in such a way that future messages, when they're encrypted and sent, are actually not going to be readable by the attacker and again return to a state of privacy where Bob and Alice have only private messages. The fifth property is one that we'll call metadata privacy. And metadata privacy is an important property as well. So metadata privacy is the notion that while your message content might be encrypted, there's metadata about the message or around the nature of the communication that's also important to keep secure. For example, Alice and Bob might not want the world to know that they've been talking or how many times they've been talking because that in and of itself can leak data about their conversations or what they're trying to communicate with each other. And so we want to make sure that we minimize this as much as possible so that an observer listening to the transfer of messages isn't able to deduce when Alice and Bob are communicating or able to glean any other information that they can use to understand or decode parts of Alice and Bob's communication protocol. Metadata privacy is difficult to eliminate entirely, but we can go to a great extent to actually limit the amount of data that people can actually obtain by snooping on messages or encrypted messages between different parts. So this gives us a framework to basically grade any encryption protocol. We want to make sure that it's a protocol where messages can't be forged or messages are encrypted end to end between clients, where the protocol ensures forward secrecy and break and recovery so that in the case of any compromise, the protocol heals itself and the compromise of one key does not mean that all messages are compromised, but that only a small set of messages are compromised. And finally, we also want to ensure that the metadata itself is private so that if Alice and Bob are communicating, the rest of the world is enabled to easily determine when and how and how often that they're communicating with each other.