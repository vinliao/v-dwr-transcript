We previously talked about decentralized social networks, where Alice and Bob have unique identities that represent them. This is particularly important so that when new messages are created by users, they can add this identity into the author field so that everyone knows that Hello World was created by Alice, or they can add it in their relationships such that Alice subscribes to Bob can be represented by Alice's ID over here and Bob's ID over here. So it's important that these IDs are unique. But it's also important that they're decentralized in a way that actually means that Alice and only Alice controls that identity. This is to ensure that nobody else can change these relationships or take these relationships or messages away from Alice at any point in the future, which is a very important property of a decentralized social network. Now, one way to do this is by allowing Alice to claim a username, a human readable username, like at Alice, for example, which is then mapped to and introduced into all of these objects. So the author field can now just say at Alice and Bob knows that it's from Alice. This is a straightforward system. We've actually seen this implemented in a few systems that exist today like ENS, where you can set up an Ethereum smart contract that keeps a mapping of usernames and connects them to Ethereum accounts. It can also ensure that usernames are unique. The same username cannot be issued multiple times, and they can only be associated with a particular Ethereum account, and so on and so forth. So this achieves a decentralized namespace, but it introduces a problem, which is that decentralized names often aren't trustworthy. So let me give you an example. Let's say that Alice had instead of grabbing at Alice, she'd grabbed at Google. Now, all of these messages on the network look like they're from Google and not from Alice. So when Bob looks at these messages or joins a network and sees all of these messages from Google and these other entities that aren't actually from Google, that creates a pretty crappy user experience. So an untrustworthy namespace is not a particularly useful one, and we want to find a way to make our namespace trustworthy. So the way Farcaster approaches this problem is by introducing a new concept known as the Farcaster ID. So rather than grabbing these human-readable usernames, Alice will actually grab an FID, which is a numeric identifier that looks like this. This is the identifier that's used in all our messages. So every time Alice does something or issues a new message, it contains this identifier and this identifier alone. This is particularly important because this identifier is designed in a way that it's fully decentralized. It's issued by a smart contract. Once Alice gets it, it's hers for life. You can issue them in near infinite quantities so they never run out, and everybody can get an identifier, and so on and so forth. The problem with these identifiers is they're somewhat tedious and not friendly to type. If Bob wanted to mention Alice and had to type at 3, 4, 8, 9, that's annoying. So we actually allow Alice to gain an optional username that she can connect back to this ID, such as addAlice. This happens in a separate system, and it's a secondary identity system. It's also unique, but it can only be associated with one of these names. At render time, clients know that add3, 4, 8, 9 is also connected to addAlice, and can go ahead and replace this here. Now, a key difference between the primary and the secondary identity system is the primary system is fully decentralized. Once Alice gets it, it's hers for life. Whereas the secondary identity system is actually governed by the namespace. So the namespace might have a set of rules, let's say for example, that you can impersonate somebody. So if Alice was actually grabbing at Google, for example, and was posting messages on that path, the namespace could claim back this name and say, hey, you're no longer allowed to use this, we've taken your name away from you. But importantly, even when this happens, all of these messages and all of these relationships continue existing because Alice is still in control of this ID, 3, 4, 8, 9, which at a later date, she can go and tie back to a different username, like Alice123, and then all the clients will simply replace this username, which is largely a cosmetic identifier at this point, that makes it easier to identify someone, but it's no longer your primary ID. Separating the concept of an identity into a fully decentralized primary ID called the Forecaster ID, and a governed namespace called the ForecasterName, actually allows us to achieve this balance between having a decentralized namespace, but also ensuring that it's trustworthy at the same time. The way it's implemented is we have a second contract on the Ethereum blockchain that maps ID numbers to addresses. There's two contracts, the ID registry and the name registry that form the basis of the Forecaster Identity System. Users must have a primary ID, they must register one of these before they can create messages, and they can optionally choose to register an FName or a ForecasterName. By connecting it to the same account, you link the FName and the FID together, and applications can actually render a username when people are browsing applications. This is the fundamental building block of the Forecaster ID system and we'll talk about authentication in our next video.