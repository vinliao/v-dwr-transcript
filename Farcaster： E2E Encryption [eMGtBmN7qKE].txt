Let's discuss a scheme that Alice and Bob can use to send messages to each other. Alice has a message, hello world. She wants it to send it from her phone to Bob's phone, which is usually accomplished via a server, but she doesn't want the server or anyone in this public space to be able to read the message. The message must go securely from Alice's private space over here to Bob's private space over here. Now, one way to accomplish this is by using what's called a symmetric encryption key. If Alice has a secret symmetric key, and if Bob also has the same secret symmetric key, then Alice can take her message, encrypt it using this key so that nobody in the middle can actually read this message and send it over to Bob. Once this message lands on Bob's side, if Bob has the same symmetric key, he can decrypt it and get the same hello world message. Now, we just need to establish a way for Alice and Bob to actually be able to get to a shared symmetric key. This is a bit of a problem because Alice and Bob may not be in the same physical location, they may not know each other when the conversation starts, and the server is untrusted so we can't have it handle the symmetric key. We need a way to derive this key in a secure way that it's never touched the public Internet, but Bob and Alice have this on their devices. What we do is we have Alice and Bob generate another type of key, we're called an asymmetric key. Now, an asymmetric key has two components. There's a private key, and we'll call this private key A because that's what Alice produces, and there's a public key, and we'll call this public key A, which is the public component to this key. We'll mark this green over here because this component can actually be safely uploaded to a server and shared with the world because it doesn't compromise the security of the key. The private key is the only part that needs to be kept secure. Now, Bob also similarly generates another key pair, but this is a totally different key pair. We'll call this public key B and private key B, and they have no relation to each other. There's two separate keys that were derived on each of their mobile devices. An interesting property that we can use here is that public keys and private keys can be combined using an algorithm known as the Diffie-Hellman algorithm to produce another shared value. What we actually do here is we have Alice take Bob's public key, which is public and available freely, and combine it with her private key to derive a shared value. We can actually use this value as a symmetric key, so we call this symmetric key C. Now, the cool thing is when Bob performs the inverse of this operation, but if Bob takes his private key and combines it with Alice's public key, Bob will also derive the exact same value. This actually allows Alice and Bob by creating asymmetric key pairs to actually derive a secret symmetric key pair that nobody else can ever compute unless they were aware of one of these private keys. This is a really cool piece of technology that allows Alice and Bob to land on a symmetric key, which can then be used to encrypt all of these messages between each other as we showed above. This helps us achieve end-to-end encryption. The message was always in plain text over here, gets encrypted, is always encrypted as soon as it leaves the device, and it's only decrypted on the other device, and all of these private keys have never left the device. Nobody else has an option to learn about these keys or is able to use them to break into these messages. The system does not, however, guarantee the other properties that we talked about yet. For example, there's no notion of forward secrecy, since there's only one symmetric key that's used to encrypt all the messages. If someone were to ever find out what that symmetric key was, let's say Alice accidentally leaked it from her phone, then all future and past messages would be compromised. We also haven't talked about a way for Alice and Bob to negotiate any kind of communication, any kind of recovery system so that once the key is recovered, like Alice and Bob still have to set up a new key and repeat this process all over again. We don't have break-in recovery either, which is the other important property we talked about. Finally, we still don't have metadata privacy, which is the server can still see messages going between Alice and Bob. Even though it can't read the messages, it knows, roughly speaking, that Alice and Bob are communicating with each other and can tell you how often they're talking to each other and so on. Those three properties, forward secrecy, break-in recovery, and metadata privacy, we haven't yet achieved, though we've achieved end-to-end encryption, which is super important with this scheme. We actually use this scheme in another place as well, in Farcaster outside of direct messages. If you've ever used the login with QR code feature, when you scan the QR code, what's actually happening is that your two different devices, your phone and your desktop, are actually setting up different public and private keys, and then deriving these symmetric keys, and using that to encrypt your recovery phrase or your seed phrase, and actually send that securely from one side to the other side. That's how we transport your credentials securely from one device to another device in a way that our server can never know what the contents of that device were. Cool. In future videos, we'll talk about how we add all those other interesting properties that are not yet part of the system by building on this primitive of the Diffie-Hellman exchange.