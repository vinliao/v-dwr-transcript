All right, I want to start off by setting up the four problems that we're trying to solve with Barcaster. So let's begin by defining a social network with our protagonists, Alice, Bob, Claire, and David. Now, a social network is one where people can send different kinds of messages to each other. And they might be text messages like, hello world. They might be images like image.png that different people are sending, or different types of media. These things can also be actions, like Claire likes Alice's post, for example. And every social network you can think of can basically be reduced to a set of users and actions that they perform on other users. Snapchat is effectively a network where the images are ephemeral. They last only for a certain amount of time. And they're permissions so that only a specific set of people can see them. Now, with a decentralized social network, we'll add one constraint on top of this model. We'll say that a decentralized social network is one where people can also use different applications to actually talk to each other. So Alice, for example, might use Snapface, a popular social networking client, while Claire and David might actually end up using FacePro 2000, a different and more advanced social networking client. And the important thing is that all of these users can communicate with each other irrespective of the apps that they're using. Now, the problems that we face when dealing with decentralized social network is the first one is a problem of identity. So an identity in a social network is often a unique identifier, like a username or an ID number, like at Alice, for example, along with a bunch of non-unique stuff. So this might be a display name, a profile picture, a verification checkmark. And this whole bundle of stuff, when it shows up on someone's profile, is how you recognize that they are the Alice that you think they're supposed to be. Now, in a decentralized social network, you need to be able to claim an identity in a way such that no one else controls this identity. So it's important that Alice is able to sort of jump between Snapface and FacePro and continue using her same identity of Alice, which means that Snapface itself doesn't control this identity. Alice is the only one that controls this. So decentralized social networks must be able to issue decentralized identities as well that map to real-world entities. The second problem that we face is one of authentication, which is that when Alice creates a message, it's important that everybody can trust that this message, hello world, came from her. So if Claire or David received this message, for example, they need to be able to authenticate the message because it comes through a bunch of untrusted parties along the way. And they need to know that none of them have tampered with this message as it's been in flight. And so that's a very important property when you have hundreds or thousands of different services and applications all handling and passing messages back and forth between each other. The third problem you run into is one that we call availability. So in a social network, you can imagine that there are millions of users creating lots and lots of posts. And let's say someone else wants to launch a new social network, a social networking application. So they want to launch a new app over here and connect to the network. Now, it's very important that this application can guarantee that if Alice jumps over here, she's still able to see all of these different messages that have been generated on other social networks. That is, the data is always available no matter what applications she switches to. If a new app wasn't able to guarantee this, Alice wouldn't switch, and the network would become less decentralized as a result. And there's a fundamental tension here, because if users can generate an infinite number of messages, let's say David generates a billion messages, then Alice or this new application can't realistically index all of this stuff. And so availability requires making sure that the data can move quickly between applications, but also ensuring that there are reasonable constraints on the size and volume of that data changing so that the network can actually become reasonably available. And the last problem we'll call as one of consistency, which is social networks have certain rules. So for example, our social network might say that every user can like a post only once. And so what happens if Claire on her application actually sets up two different messages that say that she likes Alice's post at two different times? This creates a problem, because Alice using Snapface might decide that the first one is valid and use this timestamp, whereas Bob using a different client might actually say that the last one is the valid timestamp. And so when using these different networks, these two users get a different view of what happened, because each of their applications has had to make independent decisions on enforcing the rules of the network. And this is not ideal, because it leads to divergent state. So we also want a network that can enforce certain rules of consistency and make sure that everybody agrees on the same message and discards earlier messages. And it discards conflicting messages. So these are the four core problems, identity, authentication, availability, and consistency. And we'll talk in future videos about how Farcaster solves these particular problems.