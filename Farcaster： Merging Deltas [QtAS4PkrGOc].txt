So we previously talked about how a merge function could take a series of deltas from a user and even if they conflict with each other combine them to produce the same result. Now let's look at that with a specific example in this case a like message or a reaction. So let's assume that Alice has created a message and Bob likes Alice's message. So first off for each message we'll define what we call a conflict ID which sort of defines a unique object in the graph being modified. So in this case it's Bob, hello world, and like. And we also define another thing which is a state in this case we're sort of setting it to true and so the conflict ID and the state kind of combined together produce the delta message. Now one challenge is what happens if Bob accidentally creates two messages and sends them to the forecaster. So you kind of see two messages that have the same content you don't want them to increment the number of likes that Alice gets twice. So what we do here is we actually introduce a unique ID in the form of a hash. So we simply take the contents of the message and we hash them and as long as the contents haven't changed the hash is guaranteed to be unique. So in this case we'll end up with a hash like this and it turns out that this message since it has the exact same content has the exact same hash. And so that provides a very simple way for Hub to say hey I already know about this message I'm not going to update my state let's just ignore this one for now. And so duplicate messages are handled in a very easy way. Now what happens when the state change actually conflicts? In this case let's say that Bob actually unliked the message so the state is now false and let's also say that well the hash also changes right so instead of 213 you might sort of have like 245 something something something. And so in this case the Hub can't just rely on the technique that it used before because obviously the two hashes are not similar. So what the Hub does instead is it relies on another user reported property which is the timestamp. So users are allowed to sort of specify an ordering for those messages by providing a timestamp so the users can kind of indicate hey I want this message to be created after this message and this provides a very easy conflict resolution scheme right we can sort of say that hey we got these two messages ones after the other they both conflict so let's just keep this one and move on. Now the challenge in distributed systems is that time is often unreliable and you know users might accidentally or intentionally send the same timestamp for the same messages and that kind of creates a little bit of confusion over here right so if we get both of these messages they have different hashes but the same timestamp we now have to make a decision on what to do because we can't keep both of them at the same time. And what the Hubs end up doing in this case they use the hash as a tiebreaker so we say that you know because the timestamps tie we'll actually look at the hash and you know we'll define an ordering on the hash. So we'll say that this starts with two this is two they're the same this is one this is four and arbitrarily we'll say that the higher hash the one with the greater number or the greater lexicographic order is the winner and we'll go ahead and discard this hash. Now this kind of maps to user intent for the most part right if the user has given us explicit timestamp and said this one's later than this one we'll respect that if they've given us conflicting timestamps then we'll make an arbitrary but deterministic decision that will happen the same way no matter how these messages are received. And so that allows us to guarantee that Hubs that see the same messages always end up in the same state and this is an important property right so like let's imagine that you know the actual sequence of events goes like Bob likes a message Bob unlikes it Bob says that was an accident and decides to like it again so at a future timestamp let's call this 99 Bob actually produces a different hash and a different message and this one actually says that Bob likes it again. Now the cool thing about the algorithm that we've defined is that no matter which order these messages arrive they'll always end up in the same state so you could have the messages sort of come in this order so when this comes in and this one comes in we'll compare the timestamp and then the hashes and let this one win and then when this and this combine together we'll let these two win. But let's say we sort of flip the order around right and actually this message and this message arrives well we actually end up in the same state because we compare the timestamps we realize that this one's later and we keep this one we compare these two we realize this timestamps later and we discard this one so in both cases we end up selecting this is the winner and this is sort of a very important property right because in a in a social network you can have thousands and thousands of messages and it's very common that lots of them are going to get dropped going to get reordered as they go between hubs and all kinds of errors happen and if we can design a system that's resilient to those errors that sort of says like hey no matter how you send these deltas or what order you send them in I'll always be able to get a deterministic state that's a very useful property because it takes all these actions that users are performing and merges them into a into a distinct state and then tells developers hey here is the current state of the network and it guarantees that hubs even when you have hundreds or thousands of them can all come into sync and agree on the same state over time