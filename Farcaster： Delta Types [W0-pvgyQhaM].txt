Now that we've talked about how deltas are merged and how the delta graph is produced, I want to talk about the different types of deltas that users can create on a system. So one of the deltas that users can create, we've already talked about, is the notion of casts or public broadcasts of text that are visible to everybody on the network. Another type, and we also discussed this previously, is the reaction type, where you can react to a cast or even a non-cast object like a web page or something else. And reactions have different flavors, so you can have likes, you can have recasts, and we may add more types in the future, but they effectively represent a relationship between a person and an object. We also have what we call amps. So amps are endorsements of one user by another user, where you can sort of boost another user to people who are subscribed or following you on the network. And we also have verifications. So verifications are proofs of ownership. So it's effectively a two-way signed message. So you sign it one directionally from, for example, your Ethereum wallet and another direction from your Forecaster wallet, and it proves that these two are connected together. And so this is how you can link different wallets and get your NFTs to show up in Forecaster and things like that. We also have user data. So this is metadata about the user. You can think of this as like your biofield, your profile picture, and all of the stuff that builds up your profile. And there's a narrow set of predefined things that you can add over here. And finally, we have what we call signers. We've talked about this before when we talked about authentication, where signers are sort of a silent data type. They're the very first one you establish to establish a new signing key pair. And then you sign all the other messages with the signers that you previously established. So they're sort of special in that you've got to set up a signer first, and then you can go create these messages. Now one interesting thing that we talked about in reactions, how you can have likes and unlikes, and you can change the state of reactions. But for some of these data types, you may actually want to delete something permanently. So let's take a cast, for example, where you've said, hello world. And this had a hash of some sort and a timestamp. And you no longer want this message, and you want to get rid of it. This is a common feature in a social network. For a variety of reasons, you may disagree with something you said previously you no longer wanted on your page, and you may want to get rid of it. It's not a permanent purge. Obviously in a public social network, unlike Twitter, anyone can take a screenshot of your post. And on Farcaster, anyone can copy your message with your signature and proof that you've said it later. But it's sort of a temporary, like, get this out of my profile. I no longer want it there. And the way we do deletes on Farcaster is we introduce a special type of message called delete message. So some deltas are add messages, where you can actually add a new message, like so. And others are delete messages, which actually remove previous content. So the delete message doesn't actually contain the message itself. It rather just contains a reference to the hash of the message. So it just says, remove this message. And it has its own hash, which is obviously going to be distinct. So we'll call this something else. And it also has a timestamp, which usually is going to end up being later than when the message was created. And so when a hub sees a remove message, it actually discards the add message and holds onto the remove message. And if anyone tries to put the add message back on the hub, the hub can kind of compare this hash with this hash and say, oh, no, I already got a command to remove this. I'm not accepting it, and can just reject future messages. So this allows us to encode the notion of delete in the system, but also a type of delete that eradicates the content of the original message and no longer preserves it on the hub. Now, you can sort of model hubs using this little diagram that I made over here, where you can think of each hub as having a set of boxes, each of which stores one particular data type. So as Alice creates casts, they kind of go into this box over here. As she creates reactions, they go into this box over here, and so on. And all users' messages kind of get aggregated. And you see little messages in either added states, where they're added and taken to the network, or in replaced states, when they have been deleted from the network. And the boxes, you can think of them as implementing the merge functions that we discussed earlier. So they're not going to contain all of the messages that were created, but they're only going to contain the set of deltas necessary to produce a valid graph, meaning that as a delete message comes in, the older add message might get discarded because it's no longer relevant. And so it's a very efficient representation of the data. So if you like something, unlike something, like something, unlike something, like something, sort of keep toggling it, it'll only keep the most recent message, and all the older ones can be discarded to save space. And this is a very efficient data structure for storing network data on the hubs. Now if you're familiar with computer science-y terms, one way to think about this little box over here is this is a CRDT, or a conflict-free replicated data type, which means that as the messages get merged into the set, all the conflicts can be resolved locally. And this has a bunch of useful properties that we'll get to when we talk about sync later on in the video series. Cool, that's all for now.