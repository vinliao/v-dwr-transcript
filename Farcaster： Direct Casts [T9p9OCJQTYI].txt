We've been thinking about how to support direct messaging, or as we call it, direct casting, on the Farkaster protocol to augment the public nature of messaging on Farkaster today. So today, Alice and Bob can send public messages to each other, but it would be really nice if Alice and Bob can send direct casts of private messages between each other so that they can take a public conversation and extend it into a private conversation between the two of them. And it's sort of useful to jump between these modalities as you're using the social network. So we've been putting a little thought into how we'd like to build this, and I wanted to walk you through some of our thinking today. So in order for a direct messaging product to be useful, we actually needed to achieve a few different goals. The first is that it would need to be secure. So if Alice sends a message out, she knows that Bob and only Bob can read that message. The second is it would need to be reliable, so that if Alice sends out a message, she has a high degree of confidence that Bob is able to receive and read the message that she sent to him. And the third is it needs to be useful. So a base case of being useful, which we'll launch the product with, is being able to send a direct message between two people. But you can imagine that there's a lot more that goes into making the client actually useful. For example, you might want links that you said to be auto-expanded. You might want to get read receipts. You might want reactions to messages. You might want to be able to have people do groups and have group messages. And there's a long list of features that actually go into making a messaging client very useful to people beyond just, I can send bits of text between people. And finally, you also want the client to be open. And open here means that users on different Farcaster clients are going to actually be able to message each other irrespective of which Farcaster client they're using. So it actually creates a really powerful network that anyone can plug into. Now these goals, while very desirable, are difficult to achieve all at once. And in fact, there's no implementation out there today that achieves all of this at once. And part of the problem is that some of these goals actually make the other goals harder. While you can kind of go and fairly in a straightforward way, build a very open messaging protocol or a very secure messaging protocol, it's actually hard to build one that is, for example, both open and secure. And a simple reason why is security is often guaranteed by the client. So your app on your phone is what does all of the encryption and handles the messaging. But if you say that it's open and anyone can build an app and your message could be read by any other application, there's an implicit trust of the cryptography that that application is performing. And you can't guarantee that messages that Alice sends will only be readable by Bob if Bob actually uses a very insecure client that's leaking a lot of data, either intentionally or accidentally. And so the way we want to approach this is to bite off the problem bit by bit and build towards a good solution. So we're going to start kind of from the top over here. Let me actually make this a single-ended arrow. So we want to start by initially making it secure. And I think we've laid a good foundation for this today. And we're working on making this super reliable. So we want to make sure that when you send a message, you have a high degree of confidence that the message is going to be received. And we're going to spend a good chunk of our time over the next few months working on these two portions. Over time, you'll see us expand into useful and open areas where we actually work on extending the feature set and adding more and more things and start working on ways in which we can make it so that different users on different clients can all communicate with each other. And this hopefully provides a framework to show you how we're thinking about developing this over time. So early on, the Farcaster messaging protocol or the Direct Cast protocol is going to be secure and reliable, but not necessarily open. And what that means is we're actually going to build it within the Merkle client to start. So as you know, there are many Farcaster clients. You end up at Merkle, Discov, Purple, and many, many more. But the initial implementation of this, which is focused on security and reliability, is going to work primarily on Merkle. Merkle is going to do the first implementation of this to get this to a place where it's stable. And then we'll start prototyping ways to make it work with other clients. So if Alice and Bob are using Merkle clients on day one, they're going to be able to message each other and communicate with each other using direct messages. But if they log into Discov, for example, that's not going to be able to open their messages. Now, Discov can implement its own messaging system. But over time, what we want to do is actually make it so that the protocol is open. And once this is a little more established, we'll kind of make it so that even if the user is using Discov, they're going to be able to communicate with a client that is on Merkle today. And that will actually make the whole protocol open. So hopefully that gives you an overview of how we're approaching the problem. Step one, secure and reliable. Step two, useful and open, and how we're expanding that over time. In future videos, I want to dig into a little bit more of the mechanics behind how we actually ensure that messages are secure and walk you through the security model and things that we established there.