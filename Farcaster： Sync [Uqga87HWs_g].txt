We're going to talk about how sync works on the Forecaster protocol. So when you have an application, this little orange box over here that produces a message, you care about two things. You want to make sure that this message, created by a user of this application, gets propagated to every other hub and every other application very quickly. And you also want to make sure that this process is reliable so that these messages always are guaranteed to show up on other applications. The way we achieve this is by having hubs set up a gossip communication protocol with each other. So each hub knows the address of every other hub on the network. It opens up a UDP connection to the network and then sends messages over this gossip channel. So let's say a user creates a new message or a delta. They upload this from the application to the hub over an RPC API, and the hub will go ahead and send this out over the gossip channel to every hub that it knows about, which can then update their own internal state and alert their applications that there are new messages. Now, one problem with gossip is that messages can sometimes be lossy. So let's say we have another message over here. Sometimes this can make it across to one hub, but then fail entirely to make it across to this hub, leaving it in a slightly different state. The other challenge is that gossip doesn't guarantee the ordering of messages, which in some cases is important to reach consistency. Remember, we talked earlier about how there are certain messages called signers, which are represented with these solid squares over here, and all other messages have to be signed by the key pair present in that signer message or the public key present in that signer message. The challenge here is let's say that somebody introduces a new signer, right? They decide to change the default key with which they sign messages and will represent this with blue over here, and they upload it to this hub. They then upload another message, which is signed by this new blue signer, which gets uploaded to this hub and everything's fine. Now this goes ahead and gossips out these messages. So the new signer gets sent over first, it's accepted, we all are aware of the new signer, then the new signer message is sent out and that also gets accepted. But if they end up going in the reverse order, let's say this message goes first, this hub will reject it because it isn't aware of the signer and thinks this is an unauthorized message. So this sort of goes away. And then later when this message shows up, it'll be accepted. But now again, this hub's in a state where it's missed one of these messages and we'll never see it again because the gossip protocol doesn't broadcast itself. So in order to bring hubs into state, we actually have to introduce a second process that we call an out of band sync process. So hubs also periodically will talk to each other and request a full state. So what they'll do is they sort of have a Merkle tree that represents the state of all their messages, and they'll do a comparison, they'll find all the missing messages, and then they'll go ahead and download these messages over this channel and add them over here. Now the difference between these two sync processes is that gossip is super fast, so it guarantees that most of your messages get out in a couple of seconds, whereas diff sync is thorough, but is very slow. So it takes much longer to perform a full diff. It uses TCP and more reliable connections to download these messages. And so this process is much more expensive. So gossip might happen many times a second or every few seconds, while the diff sync process may happen once or twice a minute, just to help hubs catch up with any state that they've missed out on. Now one other thing to talk about is how new hubs enter and join the network. So let's say you have a new hub, and it comes in over here. Each hub must at first know the address of at least one other hub on the network to begin the bootstrapping process. And there'll be public hubs advertised one run by the forecaster protocol, and it should be pretty easy to get these addresses. But this hub will immediately set up a gossip connection to this hub and start downloading the contact information of all these other hubs, and then go ahead and set up communication channel with all of these hubs as well. So at this point, you have channels open between this hub and every other hub, and they start receiving messages over gossip. Now because this hub starts off in an empty state, it will also perform a full diff sync with this first hub, downloading all of the messages it knows about to catch up to the most recent state of the network. So it'll actually also have an immediate diff sync channel, and then we'll continue to do this periodically every few minutes or so. So this is how our sync architecture works. We use a combination of gossip to send out messages very, very quickly, and a diff sync process or an out of band sync process that helps us catch up to messages that gossip didn't deliver that accurately, that ensures that we will always converge to the same state and have all the same messages across applications. Now, this is a very simple architecture. There's a lot of knobs we can tweak over here, including creating sub meshes within the gossip network and optimizing the delivery of these messages. But we're going to start simple and have it be a more flood-like system where all the messages are broadcast out. And as the network of hub grows, we can make improvements to this over time.