In our last video, we talked about how Alice and Bob can achieve end-to-end encryption by using an asymmetric key pair system to generate different asymmetric keys and then use that to produce a shared secret which they could use to encrypt any message that they send out. So this ensures that they both have a secret that's only known to their devices that can be used to encrypt messages before they ever leave their device, creating end-to-end encryption. Now we'd like to add some other properties to this as well. The first of one being, how do we actually know that this public key A belongs to Alice and not Charlie who's saying that he indeed is Alice? Bob needs a way to verify that this public key actually maps to the person Alice. So one way of doing this is we know that Alice has a Forcaster account with an address on the Ethereum blockchain called the custody address that actually holds the username Alice and this exists somewhere on chain. So what we have Alice do is we have her sign a message connected to this public key which is signed by this custody address that says, hey, I'm the custody address that owns Alice and I'm authorizing this public key on my behalf. So this produces a new signed message which Alice then makes publicly available and Bob fetches it along with Alice's public key and can verify the chain of ownership and knows that A does indeed belong to Alice. So it's a very simple system that is implemented for every user and once it's done, Alice and Bob both have anti-forgery properties and we know that a certain message came from one of them. Now we also want to extend our system to add the notion of forward secrecy because if this secret key that Alice and Bob generate is ever discovered, the attacker would be able to look at all past messages that Alice and Bob have exchanged and we would like that to not be possible. So to do this, we introduce the notion of a key derivation function and what we do is when we get this secret output, we previously said it was going to be used as a symmetric key, but instead of doing that, we'll actually use this as a KDF input key. And what that means is the message hello world is actually not going to be encrypted with this key and we'll kind of move this down a little bit to signify that. The KDF key is instead going to be used to populate a KDF function which generates more keys. So when the KDF function is run, we'll denote this with a little diamond over here, it will actually, using this KDF key, produce two new keys for Alice. So let's kind of draw this line over here. So one of the keys that's produced is going to be the next KDF key, so we'll call this KDF key 2. And the other key that it's going to produce is a message key which we'll call M key over here, or we'll call this M key 1 to keep this simple. And so what we're seeing happen over here is that two new keys are being produced every time the key derivation function is run, and if you have this key, if you have KDF key 1, you can get to KDF key 2, and if you have 2, you can produce 3 and so on. But if you have 2, you can't go backwards to 1. And what we do now that we have these two keys is we use this message key, or M key over here, to actually encrypt the message hello world, which is then sent across to BOP. So we send this message over here in encrypted format, BOP receives the message, and BOP runs the exact same process on the other side. So BOP is able to use his KDF key 1 to derive the same KDF key 2 in the message key 1, and BOP can then use this message key to decrypt this message and read that it says hello world. And Alice and BOP can kind of keep this going in a ping pong fashion, right? Now BOP wants to send another message back to Alice saying hi Alice, so he puts KDF 2 into a function, and this would give him KDF key 3 and message key 2, which are derived from this, and he uses it to encrypt the message hi Alice. Again this becomes an encrypted blob over here, and then Alice runs the same function again to generate the exact same messages. Alice now has KDF key 3 and message key 2, and Alice can use message key 2 to decrypt this new message that actually says hi Alice, we'll kind of drive from over here. And Alice is now able to decrypt this message. And so you can kind of see how Alice and BOP are able to keep extending the single key into multiple keys, each of which can be used to encrypt a message. And this has some nice properties. If you were to break message key 1, for example, all that you could do is decrypt this particular message and know that Alice said hello world, but you're not going to be able to decrypt other messages. If you had KDF key 2, or let's say KDF key 3 in this case, you're not going to be able to go back and figure out the message key 1 or KDF key 2 to decrypt this message. You are going to be able to break future messages, so you can use this for example to generate KDF key 4 and 5 and 6, but you can't go backwards and figure out what messages Alice and BOP have been exchanging. So the addition of this KDF key and using the secret to generate more secrets with a hash function lets us generate new keys for every message in a way that Alice and BOP both have them, giving us forward secrecy to our system.